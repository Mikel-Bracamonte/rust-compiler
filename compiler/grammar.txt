gramatica del profe:

Program ::= VarDecList FunDecList
VarDecList ::= (VarDec)*
FunDecList ::= (FunDec)+
FunDec ::= fun Type id ([ParamDecList] ) Body endfun
Body ::= VarDecList StmtList
ParamDecList ::= Type id (, Type id)*
VarDec ::= var Type VarList ;
Type ::= id
VarList :: id (,id)*
StmtList ::= Stmt ( ; Stmt )*
Stmt ::= id = CExp |
print ( CExp )
if CExp then Body [else Body] endif
while CExp do Body endwhile
for id in range ( CExp , CExp , CExp ) Body endfor
return ( [CExp] )
CExp ::= Exp [(<|<=|==) Exp]
Exp ::= Term ((+ | -) Term)*
Term ::= Factor ((*|/) Factor)*
Factor ::= id | Num | Bool | ( Exp ) | ifexp ( CExp , CExp , CExp ) | id ( [ArgList] )
ArgList ::= CExp (, CExp)*
Bool ::= true | false

propuesta 1:
Program ::= VarDecList FunDecList

VarDecList ::= (VarDec)*

FunDecList ::= (FunDec)+

FunDec ::= fn id ([ParamDecList]) -> Type { Body }

Body ::= VarDecList StmtList

ParamDecList ::= id: Type (, id: Type)*

VarDec ::= let [mut] id: Type;

Type ::= id

StmtList ::= Stmt ( ; Stmt )*

Stmt ::= id = AExp |
println!("{}", AExp ) |
if AExp { Body } [else { Body } ] |
while AExp { Body } |
for [ mut ] id in Num..Num { Body } |
return [ AExp ]

AExp ::= BExp ((&& | ||) BExp)*

BExp ::= CExp | !CExp

CExp ::= Exp [(<|<=|>|>=|==|!=) Exp]

Exp ::= Term ((+ | -) Term)*

Term ::= Factor ((*|/) Factor)*

Factor ::= id | Num | Bool | ( AExp ) | if AExp {AExp} else {AExp} | id ( [ArgList] )

ArgList ::= AExp (, AExp)*

Bool ::= true | false
